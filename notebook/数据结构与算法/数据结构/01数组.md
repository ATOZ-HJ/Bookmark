## Array

1. 非受限的线性表
2. 顺序结构
3. 支持O(1)的随机访问
4. 平均为O(n)的插入和删除
5. 警惕编码中的数据越界，导致 stack over flow





### [Leetcode26](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

#### 题目描述

**题意**

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。



**说明**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```



**示例1：**

```
输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```



**示例 2：**

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```



**提示：**

- `0 <= nums.length <= 3 * 104`
- `-104 <= nums[i] <= 104`
- `nums` 已按升序排列



#### 双指针

1. 数组排序，如果有重复的元素，那么重复元素相邻
2. 使用快慢指针，快指针用于遍历元素，慢指针用于存放不相同的元素
3. 数组如果长度为0 ，则直接返回
4. 如果fast指针处的元素和fast指针前一个元素相等，说明元素重复，则继续遍历下一个元素；否则交换快慢指针处的元素
5. 最终 [0,slow)处的元素都是不重复的元素

```Java
    public static int removeDuplicates(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int slow = 1;
        for (int fast = 1; fast < nums.length; fast++) {
            if (nums[fast] == nums[fast - 1]) {
                continue;
            }
            nums[slow] = nums[fast];
            slow++;
        }
        return slow;
    }
```



### Leetcode27

#### 题目描述

**题意**

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。



**说明**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```



**示例 1**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```



**示例 2**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`



#### 双指针

1. 与leetcode26相似，使用快慢指针
2. fast指针为遍历到的元素
3. slow指针存放目标元素

```Java
public int removeElement1(int[] nums, int val) {
        if (nums.length == 0) {
            return 0;
        }
        int slow = 0;
        for (int fast = 0; fast < nums.length; fast++) {
            //右指针元素与val相同
            if (nums[fast] == val) {
                continue;
            }
            nums[slow] = nums[fast];
            slow++;
        }
        return slow;
    }
```



### Leetcode283

#### 题目描述

**题意**

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**示例:**

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**说明**:

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。



#### 双指针

1. 与26和27两题类似
2. 快慢指针，快指针遍历，慢指针位置存放目标元素

```Java
public void moveZeroes(int[] nums) {
        int slow = 0;
        for (int fast = 0; fast < nums.length; fast++) {
            if (nums[fast] != 0) {
                int temp = nums[slow];
                nums[slow] = nums[fast];
                nums[fast] = temp;
                slow++;
            }
        }
    }
```



### Leetcode70

#### 题目描述

**题意**

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。



**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```



**示例 2：**

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```



#### 动态规划

由题意，每次只能爬一级或者两级台阶，由此可知爬到第n级台阶可以分为以下两种情况

1. 从第 n-1 级台阶爬一级到达
2. 从第 n-2 级台阶爬两级到达

由此可以得到动态规划的**转移方程**:

```
f(n) = f(n-1) + f(n-2)
```

3. 滚动数组的思想减少空间复杂度

![fig1](https://assets.leetcode-cn.com/solution-static/70/70_fig1.gif)

**代码**

```Java
/**
     * 该题核心是找到递推公式
     * f(n) = f(n-1)+f(n-2)
     *
     * @param n
     * @return
     */
    public int climbStairs(int n) {
        if (n < 3) {
            return n;
        }
        //以下方式是滚动数组，空间复杂度为O(1)
        int a = 1;
        int b = 2;
        int c = 0;
        for (int i = 3; i < n + 1; i++) {
            c = a + b;
            a = b;
            b = c;
        }
        return c;
    }

```





### Leetcode35

#### 题目描述

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。



**示例 1:**

```
输入: nums = [1,3,5,6], target = 5
输出: 2
```



**示例 2:**

```
输入: nums = [1,3,5,6], target = 2
输出: 1
```



**示例 3:**

```
输入: nums = [1,3,5,6], target = 7
输出: 4
```



**示例 4:**

```
输入: nums = [1,3,5,6], target = 0
输出: 0
```



**示例 5:**

```
输入: nums = [1], target = 0
输出: 0
```



**提示:**

- 1 <= nums.length <= 104
- -104 <= nums[i] <= 104
- nums 为无重复元素的升序排列数组
- -104 <= target <= 104



#### 二分查找

**二分查找的通用代码**

1. 时间复杂度为O(log n) 

```java
public int binarySearch(int[] nums, int target) {
        int left = 0, right = nums.length - 1; // 注意
        while(left <= right) { // 注意
            int mid = (left + right) / 2; // 注意
            if(nums[mid] == target) { // 注意
                // 相关逻辑
            } else if(nums[mid] < target) {
                left = mid + 1; // 注意
            } else {
                right = mid - 1; // 注意
            }
        }
        // 相关返回值
        return 0;
    }
```



**解题**

1. 题目可以简化为在一个排序好了的数组中查找某一个值
2. 目标位置一定满足以下关系：nums[pos-1] < nums[pos] <= num[pos+1]
3. 题目直接返回left，可以通过举例来验证其正确性
   1. nums为[1,2,3,5]，target=4，可以手写验证最后直接返回下标3即可，此时left = 3
   2. nums为[1,2,3,3]，target=4，在最后一个循环的时候left = mid +1 = 4 
   3. 综上两种特殊情况直接返回left也成立

```java
public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
```









































