[TOC]

## 前言

### 做题方式

1. 内容分类：按照不同的**数据结构**做题，参考算法训练营课程的分类
2. 题目来源：算法训练营不同章节提供的**题目**，以及leetcode对应的题目
3. 题目难度：先从**简单以及中等**难度开始，对难题可以学习其思路
4. 做题成果：输出对应算法题的**笔记**，标准可以参考之前的笔记以及小马哥的笔记
5. 做题规律：在工作台excel中输出**做题计划**，按照计划执行
6. 做题步骤：
   1. 按照**五遍刷题法**进行做题
   2. 整理笔记输出到**我的算法手记**
   3. 添加题目到**数据结构与算法脑图**中



### 阶段安排

1. 第一阶段：每个数据结构10道题目，难度控制在简单以及中等
2. todo



### 切题四件套

1. 自己多看几次题目，和面试官多确认几次，确保对题目的理解是正确的
2. 想出所有可能的解法，比较不同解法的时间空间复杂度，找出最优方法
3. 开始写代码
4. 写出一些测试样例



### **五遍刷题法**

**第一遍**

5-15分钟读题和自主思考

没有思路则直接看解法，比较多种解法之间的优劣以及差别；如果有思路了则直接写出来，然后进行背诵和默写解法，可以先把想到的思路列出来。

 注意一定要去LeetCode国际站的discuss区看看各个国家的解法，至少是要了解一下点赞前三的解法。



**第二遍**

马上自己写一次，也要尝试多种解法，比较优劣



**第三遍**

过了一天之后，再重复做一次该题；训练不同解法的熟练程度



**第四遍**

一周之后重复做题



**第五遍**

面试前恢复性训练，重复做题



------



## Array

1. 非受限的线性表
2. 顺序结构
3. 支持O(1)的随机访问
4. 平均为O(n)的插入和删除
5. 警惕编码中的数据越界，导致 stack over flow



### [Leetcode26](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

#### 题意

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。



#### 说明

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```



#### 示例1：

```
输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```



#### 示例 2：

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```





