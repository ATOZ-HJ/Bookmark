## 简述Java基本数据类型  

 整型：byte、short、int、long 浮点型：float、double 字符型：char布尔型：boolean 

##  float占几个字节 

 占用4个字节 

##  简述==与equals方法的区别 

 对于==，在基本数据类型比较时，比较的是对应的值，对引用数据类型比较时，比较的是其内存的存放地址。 

 对于equals方法，在该方法未被重写时，其效果和==一致，但用户可以根据对应需求对判断逻辑进行改写，比如直接比较对象某个属性值是否相同，相同则返回true，不同则返回false。需保证equals方法相同对应的对象hashCode也相同。 

##  简述拆箱装箱原理 

 装箱过程是通过调用包装器的valueOf方法实现的，将原值赋给对应类。 

 拆箱过程是通过调用包装器的 intValue/doubleValue等方法实现，返回基本的数据类型。 

##  Java反射原理 

 Java会在编译期装载所有的类，并将其元信息保存至Class类对象中。因此可以设计x.class/x.getClass()/Class.forName()等方法获取Class对象。所以在反射调用Field/Method/Constructor对象时，可根据Class类对象进行进一步操作。 

##  AOP原理 

 AOP可采用动态代理进行实现，即通过拦截的方式，对原有方法进行装饰，用修饰过的方法取代原有对象的执行。 

##  依赖注入的方式 

 构造方法注入：IoC Service Provider 会检查被注入对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。 

 setter 方法注入：为其依赖对象对应的属性添加 setter 方法后，通过 setter 方法将依赖对象注入到被依赖对象中。 

 静态工厂注入：调用工厂类中定义的静态方法获取需要的对象。 

 实例工厂注入：实例化一个工厂类对象，调用工厂类对象的实例化方法来实例化对象。 

##  java多线程创建方式有哪些 

 java线程的实现方式有 实现Runnable接口 继承Thread类。实现Callable接口 

##  什么情况下需要重写hashCode和equals方法 

 对于业务逻辑的自定义类，如果其判断相等逻辑不是和java中equal判断逻辑一致需要重写hashCode和equals。 

 如果需要重写equals方法，一定需要重写hashCode方法。 

##  MySQL数据库存储过程 

 一般来说，普通的SQL语句需要先编译然后执行，而存储过程可以理解为为了完成特定功能的已经编译后的SQL语句集。用户可通过存储过程的名字并给定参数来调用。 

##  MySQL数据库触发器 

 触发器简单来说就是监视某种情况，并触发某种操作。当触发器所在表上出现指定事件(insert/update/delete)时，可指定时间(after/before)执行特定事件(insert/update/delete)。 

##  SQL优化方法 

 核心就是避免全表扫描，多走索引。列举常用的一些优化方法： 

1.  尽量对利用字段较多的建立索引，即在 where 及 order by 涉及的列上建立索引。 
2.  尽量避免在 where 子句中使用 or ，null值判断，in 和对字段进行表达式操作 
3.  建立索引时需要多考虑最左匹配原则 

##  什么情况下分表合适 

 针对存储了百万级乃至千万级条记录的大表。数据库在查询和插入的时候耗时太长，可通过分表，将大表拆分成小表，提升数据库性能。 

##  分表的原则 

1.  对于数据量不大的表，在满足现有性能的前提下，能不拆分就不拆分。 
2.  针对不同的业务，采取合适的拆分准则。对于大表特定列之间业务耦合性低，可采用垂直分表。对大表列数耦合性高，或者列数不多行数多的情况下，可按照某个字段的某种规则来分散到多个表之中。 

##  Redis单线程原理 

 首先必须明确，Redis单线程指的是网络请求模块使用了一个线程（，其他模块仍用了多个线程。并不是一个线程完成了所有功能。原理上，其采用了利用epoll的多路复用特性，因此可以采用单线程处理其网络请求。 

##  Redis数据类型 

 String：字符串类型，最简单的类型 Hash：类似于Map的一种结构。List：有序列表。Set:无序集合。ZSet：带权值的无序集合，即每个ZSet元素还另有一个数字代表权值，集合通过权值进行[排序]()。 

##  什么情况下使用[redis]() 

1.  针对热点数据进行缓存 
2.  对于特定限时数据的存放 
3.  针对带热点权值数据的[排序]()list 
4.  分布式锁 

##  [redis]()与memcache的区别 

1.  [redis]()处理网络请求采用单线程模型，而memcache采用多线程异步IO的方式 
2.  [redis]()支持数据持久化，memcache不支持 
3.  [redis]()支持的数据格式比memcache更多 

##  简述缓存雪崩 

 缓存雪崩指缓存中一大批数据到过期时间，而从缓存中删除。但该批数据查询数据量巨大，查询全部走数据库，造成数据库压力过大。 

##  简述缓存雪崩的避免方式 

1.  缓存数据设置随机过期时间，防止同一时间大量数据过期。 
2.  设置热点数据永远不过期。 
3.  对于集群部署的情况，将热点数据均与分布在不同缓存中。 

##  应用层的理解 

 应用层针对的不再是两台主机的通信，而是主机上特定应用的通信，方便应用程序之间进行通信。 

##  http请求包含了什么 

 包含：请求方法字段、URL字段、HTTP协议版本 产生请求的浏览器类型，请求数据，主机地址。 

##  http状态码有哪些 

 1XX：接收的信息正在处理 

 2XX：请求正常处理完毕 

 3XX：重定向 

 4XX：[客户端]()错误 

 5XX：服务端错误 

  常见错误码：301：永久重定向 302：临时重定向 304：资源没修改，用之前缓存就行 400：[客户端]()请求的报文有错误 403：表示服务器禁止访问资源 404：表示请求的资源在服务器上不存在或未找到。