## 进程和线程的区别 

 进程是操作系统中最重要的抽象概念之一，是资源分配的基本单位，是独立运行的基本单位。 

 线程是进程划分的任务，是一个进程内可调度的实体，是CPU调度的基本单位，用于保证程序的实时性，实现进程内部的并发。 

 线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。 

 每个线程完成不同的任务，但是属于同一个进程的不同线程之间共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。 

##  MySQL与Redis区别 

 mysql是关系型数据库，并且其将数据存储在硬盘中，读取速度较慢。 [redis]()是非关系型数据库，并且其将数据存储在内存中，读取速度较快。 

##  关系型数据库与非关系型数据库区别 

 关系型数据库采用了关系模型（可以简单理解为二维表格类型）组织数据，一般可以遵守事务的ACID特性 不是由关系模型进行存储的均可视作非关系型数据库，比如以键值对的[redis]()，图数据库等。 

##  TCP三次握手 

 第一次握手:[客户端]()将标志位SYN置为1，随机产生一个值序列号seq=x，并将该数据包发送给服务端，[客户端]() 进入syn_sent状态，等待服务端确认。 

 第二次握手:服务端收到数据包后由标志位SYN=1知道[客户端]()请求建立连接，服务端将标志位SYN和 ACK都置为1，ack=x+1,随机产生一个值seq=y，并将该数据包发送给[客户端]()以确认连接请求，服务端进入syn_rcvd状态。 

 第三次握手:[客户端]()收到确认后检查,如果正确则将标志位ACK为1，ack=y+1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，[客户端]()和服务端进入established状态，完成三次握手，随后[客户端]()和服务端之间可以开始传输 数据了 

##  TCP四次挥手 

 第一次挥手：[客户端]()发送一个FIN，用来关闭[客户端]()到服务端的数据传送，[客户端]()进入finwait1状态。 

 第二次挥手：服务端收到FIN后，发送一个ACK给[客户端]()，确认序号为收到序号+1，服务端进入Close_wait状态。此时TCP连接处于半关闭状态，即[客户端]()已经没有要发送的数据了，但服务端若发送数据，则[客户端]()仍要接收。 

 第三次挥手：服务端发送一个FIN，用来关闭服务端到[客户端]()的数据传送，服务端进入Last_ack状态。 

 第四次挥手：[客户端]()收到FIN后，[客户端]()进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。 

##  TCP UDP区别 

 TCP作为面向流的协议，提供可靠的、面向连接的运输服务，并且提供点对点通信 UDP作为面向报文的协议，不提供可靠交付，并且不需要连接，不仅仅对点对点，也支持多播和广播。 

##  开视频用哪个 

 UDP协议 

##  垃圾回收[算法]() 

 简述标记清除[算法]()、标记整理[算法]()和标记复制[算法]() 

 标记清除[算法]()：先标记需清除的对象，之后统一回收。这种方法效率不高，会产生大量不连续的碎片。 

 标记整理[算法]()：先标记存活对象，然后让所有存活对象向一端移动，之后清理端边界以外的内存 

 标记复制[算法]()：将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当使用的这块空间用完了，就将存活对象复制到另一块，再把已使用过的内存空间一次清理掉。 

##  悲观锁乐观锁 

 乐观锁：对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁，只有到数据提交的时候才通过一种机制来验证数据是否存在冲突。 

 悲观锁：对于数据冲突保持一种悲观态度，在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的。