## 01,02如何抓住重点，系统高效的学习数据结构与算法

适度刷题，掌握课程中的20个数据结构与算法



## 02复杂度分析：如何分析、统计算法的执行效率和资源消耗

### 事后统计法

1. 测试环境
2. 测试数据规模

### 时间空间复杂度分析方法

时间复杂度和空间复杂度都是用来衡量算法的执行效率的，都是用来表征**算法执行效率和数据规模**之间的关系的



## 03复杂度分析：浅析最好、最坏、平均、均摊时间复杂度

###  最好、最坏时间复杂度

![image-20210829110801785](数据结构与算法之美.assets/image-20210829110801785.png)

这段代码，循环中当找到目标元素后直接终止了循环，此时可能存在多种情况，最好的情况就会第一个元素就找到了，那么此时的时间复杂度就是O(1)；最坏的情况下，如果数组中不包含该元素，则时间复杂度为O(n)。

由此引出最好、最坏、平均时间复杂度

### 最好时间复杂度

在最理想的情况下，执行代码的时间复杂度



### 最坏时间复杂度

在最坏的情况下，执行代码的时间复杂度，可以参考上面举的例子



### 平均时间复杂度

对于最好和最坏时间复杂度，都是比较极端的情况才会产生的，发生的概率并不大，为了更好的表示平均情况下的时间复杂度，引入平均时间复杂度的概念。

1. 简单计算的方法

首先变量x在数组中的位置有n+1中情况：在数组的0～ n-1的位置和不在数组中，我们把每种情况下，查找x需要遍历的元素个数累加起来，然后再处以n+1 ，就可以得到需要遍历的元素个数的平均值了

![image-20210829141527141](数据结构与算法之美.assets/image-20210829141527141.png)

最后由上面的共识，省略掉低阶和常数项，最终得到的平均时间复杂度是O(n)



2. 加上概率统计的计算方法

1中的方法统计是有问题的，因为并不是每种情况出现的概率都是一样的，如果出现的概率不一样，则需要将概率统计相关的内容加进去。

我们要查找的元素，它在数组中和不在数组中的概率都是1/2，另外，要查找的数据出现在0～n-1这n个位置的概率也是一样的，为1/n，根据乘法法则，要查找的数据出现的概率是 1/ (2n)，因此推导的过程中需要将各种情况发生的概率考虑进去。

![image-20210829142508747](数据结构与算法之美.assets/image-20210829142508747.png)



### 均摊时间复杂度

先上示例代码

![image-20210829142600524](数据结构与算法之美.assets/image-20210829142600524.png)



以上，将方法入参插入到数组中，最好的情况是数组有空间，则直接插入；最坏的情况是需要遍历一遍后，数组清空后再插入，此时的时间复杂度是O(n)。

对于insert()函数来说，O(1)时间复杂度的插入和O(n)时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个O(n)插入之后，紧跟着n-1个O(1)的插入操作，循环往复。

每一次O(n)的插入操作，都会跟着n-1次O(1)的插入操作，所以把耗时多的那次操作均摊到接下来的n-1次耗时少的

操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是O(1)。

其实以上关于均摊时间复杂度的概念我也是比较迷的，但是老师有说在大多数的情况下，均摊时间复杂度就是最好时间复杂度。



## 05数组：为什么很多编程语言中数组队列都是从0开始编号

### 如何实现随机访问？

1. 数据是线性表结构
2. 数组拥有连续的内存空间和相同的数据结构。

这两点使得数组拥有了随机访问的特性，但是让插入和删除一条记录的效率变的很低。

![image-20210830223954233](数据结构与算法之美.assets/image-20210830223954233.png)

#### 为什么说数组的随机访问效率高？

1. 首先数组拥有连续的内存空间
2. 计算机会给每一个内存空间分配一个地址，计算机通过地址来访问内存中的数据，当计算机需要随机访问数组中的某个元素的时候，通过寻址公式，就可以计算出元素存储的内存地址：

```
a[i]_address = base_address + i * data_type_size
```

其中 i 可以说是我们通常意义上的数组下标，在面试中，我们不能说数组的优点是适合查找，而应该是数组支持按下表来进行随机访问，并且随机访问的时间复杂度是O(1)



**线性表**：线性表就是数据排列成像一条线一样的结构，每个线性表上的数据最多只有钱和后两个方向，除了数组，连标、队列、栈等也是线性表结构

**非线性表**：与线性表相对，数据之间不是简单的前后关系，比如二叉树，堆，图



### 低效的 插入 和 删除

由于数组要保持内存数据的连续性，会导致插入和删除这两个操作比较低效。

#### 插入

假设数组有n个元素，当我们要将一个数据插入到数组中的第k个位置，为了把k个位置腾出来，需要将k～n之间的元素都按顺序往后挪一位，我们接下来分析一下这个过程的时间复杂度，如果是中数组末尾追加元素，那么此时的时间复杂度就O(1)，如果是在数组的第一位插入，此时需要挪动的次数为n次，由此计算出来的平均时间复杂度为O(n)。

#### 如何改进呢？

如果数组中的数据要求是有序的，那么我们操作数组的时候就需要按照上述描述的，挪动k位置以后的元素。如果数组中的元素是无序的，并且对数据的顺序没有要求，只是将数组作为一个容器，那么可以将k位置的元素放到数组的末尾，然后将新加入的元素放到k位置，从而减少了数组中元素位置移动的次数，提高了插入元素的效率。

利用刚才的方法，时间复杂度就达到了O(1)



#### 删除

和新增类似，同样是为了保存数据存储在内存上的连续性，删除位置k的元素，需要将k+1～n的元素向前移动一位。当删除的末尾的元素时，时间复杂度为O(1)，如果删除的开头的元素，则时间复杂度为O(n)。

#### 如何改进呢

每次删除通常会伴随着数组中元素位置的变化，我们可以将多次删除的操作集中到一次去做，也就是当数组进行删除操作的时候，先将删除的元素记录下来，而不是真正的去执行删除操作，相当于只是记录了哪些元素被删除了，当数组没有更多空间存储数据的时候，再统一触发一次真正的删除操作。这种思想就是JVM中标记清除垃圾回收算法的核心思想



### 容器是否可以替代数组

很多语言都对数组进行了封装，主要是对数组的一些操作，以及自动扩容等内容进行了封装，方便了业务开发中使用。由于频繁的扩容可能会带来较大的性能消耗







